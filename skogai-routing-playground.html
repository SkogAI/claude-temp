<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SkogAI Routing Playground</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #0f1117; color: #e2e8f0; height: 100vh; overflow: hidden; }

  .layout { display: grid; grid-template-columns: 280px 1fr; grid-template-rows: 1fr auto; height: 100vh; }

  /* Sidebar */
  .sidebar { grid-row: 1 / 3; background: #1a1d27; border-right: 1px solid #2d3348; overflow-y: auto; padding: 16px; }
  .sidebar h1 { font-size: 14px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px; }
  .sidebar h2 { font-size: 12px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; margin: 16px 0 8px; }

  /* Mode toolbar */
  .mode-bar { display: flex; gap: 4px; margin-bottom: 12px; }
  .mode-btn { flex: 1; padding: 6px 4px; font-size: 10px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; text-align: center; }
  .mode-btn:hover { background: #2d3348; color: #e2e8f0; }
  .mode-btn.active { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .mode-btn.active-connect { background: #8b5cf6; border-color: #8b5cf6; color: #fff; }
  .mode-btn.active-add { background: #10b981; border-color: #10b981; color: #fff; }

  .mode-hint { font-size: 10px; color: #475569; padding: 4px 0 8px; line-height: 1.4; border-bottom: 1px solid #2d3348; margin-bottom: 4px; }

  /* Connect type selector */
  .connect-type-sel { margin: 8px 0; padding: 8px; background: #252836; border: 1px solid #2d3348; border-radius: 4px; }
  .connect-type-sel label { display: flex; align-items: center; gap: 6px; font-size: 11px; padding: 2px 0; cursor: pointer; }
  .connect-type-sel input { accent-color: #8b5cf6; }

  /* Presets */
  .presets { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }
  .preset-btn { padding: 5px 10px; font-size: 11px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; }
  .preset-btn:hover { background: #2d3348; color: #e2e8f0; }
  .preset-btn.active { background: #3b82f6; border-color: #3b82f6; color: #fff; }

  /* Layer toggles */
  .layer-toggle { display: flex; align-items: center; gap: 8px; padding: 4px 0; cursor: pointer; font-size: 12px; }
  .layer-toggle input { accent-color: #3b82f6; }
  .layer-dot { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }

  /* Connection type toggles */
  .conn-toggle { display: flex; align-items: center; gap: 8px; padding: 3px 0; cursor: pointer; font-size: 12px; }
  .conn-line { width: 20px; height: 2px; display: inline-block; }

  /* Comments & user items */
  .comments-list { margin-top: 8px; }
  .comment-item, .user-item { background: #252836; border: 1px solid #2d3348; border-radius: 4px; padding: 8px; margin-bottom: 6px; font-size: 11px; }
  .comment-item .target, .user-item .target { color: #60a5fa; font-weight: 600; }
  .comment-item .text, .user-item .text { color: #94a3b8; margin-top: 4px; }
  .comment-item .delete-btn, .user-item .delete-btn { color: #ef4444; cursor: pointer; float: right; font-size: 10px; }
  .user-item { border-color: #10b981; }
  .user-item .target { color: #10b981; }
  .comment-count { color: #64748b; font-size: 11px; }

  /* Canvas area */
  .canvas-area { position: relative; overflow: hidden; background: #13151f; }
  .canvas-area svg { width: 100%; height: 100%; }
  .canvas-area.mode-connect { cursor: crosshair; }
  .canvas-area.mode-add { cursor: cell; }

  /* Zoom controls */
  .zoom-controls { position: absolute; top: 12px; right: 12px; display: flex; gap: 4px; }
  .zoom-btn { width: 28px; height: 28px; border: 1px solid #2d3348; background: #1a1d27; color: #94a3b8; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
  .zoom-btn:hover { background: #2d3348; color: #e2e8f0; }

  /* Legend */
  .legend { position: absolute; bottom: 12px; left: 12px; background: #1a1d27ee; border: 1px solid #2d3348; border-radius: 6px; padding: 10px 14px; font-size: 11px; }
  .legend-title { font-weight: 600; color: #64748b; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em; font-size: 10px; }
  .legend-item { display: flex; align-items: center; gap: 8px; padding: 2px 0; color: #94a3b8; }

  /* Prompt area */
  .prompt-area { background: #1a1d27; border-top: 1px solid #2d3348; padding: 12px 16px; max-height: 200px; overflow-y: auto; }
  .prompt-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .prompt-header span { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
  .copy-btn { padding: 4px 12px; font-size: 11px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; }
  .copy-btn:hover { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .copy-btn.copied { background: #10b981; border-color: #10b981; color: #fff; }
  .prompt-text { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px; line-height: 1.5; color: #cbd5e1; white-space: pre-wrap; }

  /* Tooltip */
  .tooltip { position: absolute; background: #252836; border: 1px solid #3b82f6; border-radius: 6px; padding: 10px 14px; font-size: 11px; pointer-events: none; z-index: 100; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: none; }
  .tooltip .tt-label { font-weight: 700; color: #e2e8f0; margin-bottom: 2px; }
  .tooltip .tt-path { color: #60a5fa; font-family: monospace; font-size: 10px; margin-bottom: 4px; }
  .tooltip .tt-desc { color: #94a3b8; line-height: 1.4; }

  /* Modals */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 200; display: none; align-items: center; justify-content: center; }
  .modal-overlay.show { display: flex; }
  .modal { background: #1a1d27; border: 1px solid #2d3348; border-radius: 8px; padding: 20px; width: 400px; }
  .modal h3 { font-size: 14px; margin-bottom: 4px; }
  .modal .modal-path { color: #60a5fa; font-family: monospace; font-size: 11px; margin-bottom: 12px; }
  .modal textarea, .modal input, .modal select { width: 100%; background: #252836; border: 1px solid #2d3348; border-radius: 4px; color: #e2e8f0; padding: 8px; font-size: 12px; font-family: system-ui; }
  .modal textarea { height: 60px; resize: vertical; }
  .modal input:focus, .modal textarea:focus, .modal select:focus { outline: none; border-color: #3b82f6; }
  .modal label.field { display: block; font-size: 11px; color: #64748b; margin: 10px 0 4px; text-transform: uppercase; letter-spacing: 0.03em; }
  .modal label.field:first-of-type { margin-top: 8px; }
  .modal-actions { display: flex; gap: 8px; margin-top: 14px; justify-content: flex-end; }
  .modal-actions button { padding: 6px 14px; border-radius: 4px; font-size: 12px; cursor: pointer; border: 1px solid #2d3348; }
  .modal-actions .cancel { background: #252836; color: #94a3b8; }
  .modal-actions .save { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .modal-actions .save-green { background: #10b981; border-color: #10b981; color: #fff; }

  /* Info bar */
  .info-bar { position: absolute; top: 12px; left: 12px; font-size: 11px; color: #475569; transition: color 0.2s; }
  .info-bar.highlight { color: #10b981; }

  /* Connection source highlight pill */
  .connect-source-pill { position: absolute; top: 44px; left: 12px; font-size: 11px; color: #8b5cf6; background: #2e1065; border: 1px solid #6d28d9; padding: 3px 10px; border-radius: 12px; display: none; }
  .connect-source-pill.show { display: inline-block; }
</style>
</head>
<body>

<div class="layout">
  <!-- Sidebar -->
  <div class="sidebar">
    <h1>SkogAI Routing</h1>

    <!-- Mode toolbar -->
    <div class="mode-bar">
      <button class="mode-btn active" id="mode-view" onclick="setMode('view')">View</button>
      <button class="mode-btn" id="mode-connect" onclick="setMode('connect')">Connect</button>
      <button class="mode-btn" id="mode-add" onclick="setMode('add')">Add Node</button>
    </div>
    <div class="mode-hint" id="mode-hint">Click nodes to comment. Scroll to zoom, drag to pan.</div>

    <!-- Connect type selector (visible in connect mode) -->
    <div class="connect-type-sel" id="connect-type-sel" style="display:none">
      <div style="font-size:10px;color:#64748b;text-transform:uppercase;margin-bottom:4px">Connection type</div>
    </div>

    <h2>View Presets</h2>
    <div class="presets" id="presets"></div>

    <h2>Layers</h2>
    <div id="layer-toggles"></div>

    <h2>Connection Types</h2>
    <div id="conn-toggles"></div>

    <h2>Your Additions <span class="comment-count" id="additions-count">(0)</span></h2>
    <div id="additions-list"></div>

    <h2>Comments <span class="comment-count" id="comment-count">(0)</span></h2>
    <div class="comments-list" id="comments-list"></div>
  </div>

  <!-- Canvas -->
  <div class="canvas-area" id="canvas-area">
    <svg id="diagram" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()">+</button>
      <button class="zoom-btn" onclick="zoomOut()">&minus;</button>
      <button class="zoom-btn" onclick="zoomReset()" style="font-size:11px">1:1</button>
    </div>
    <div class="info-bar" id="info-bar">click nodes to comment &middot; scroll to zoom &middot; drag to pan</div>
    <div class="connect-source-pill" id="connect-pill"></div>
    <div class="legend" id="legend"></div>
    <div class="tooltip" id="tooltip">
      <div class="tt-label"></div>
      <div class="tt-path"></div>
      <div class="tt-desc"></div>
    </div>
  </div>

  <!-- Prompt output -->
  <div class="prompt-area">
    <div class="prompt-header">
      <span>Generated Prompt</span>
      <button class="copy-btn" id="copy-btn" onclick="copyPrompt()">Copy</button>
    </div>
    <div class="prompt-text" id="prompt-output"></div>
  </div>
</div>

<!-- Comment modal -->
<div class="modal-overlay" id="comment-modal">
  <div class="modal">
    <h3 id="comment-modal-title"></h3>
    <div class="modal-path" id="comment-modal-path"></div>
    <textarea id="comment-modal-text" placeholder="Add your comment about this component..."></textarea>
    <div class="modal-actions">
      <button class="cancel" onclick="closeCommentModal()">Cancel</button>
      <button class="save" onclick="saveComment()">Save Comment</button>
    </div>
  </div>
</div>

<!-- Add Node modal -->
<div class="modal-overlay" id="add-node-modal">
  <div class="modal">
    <h3>Add New Node</h3>
    <label class="field">Label (display name)</label>
    <input id="new-node-label" placeholder="e.g. my-agent.md" />
    <label class="field">Path</label>
    <input id="new-node-path" placeholder="e.g. .claude/agents/my-agent.md" />
    <label class="field">Layer</label>
    <select id="new-node-layer"></select>
    <label class="field">Description</label>
    <textarea id="new-node-desc" placeholder="What does this component do?"></textarea>
    <div class="modal-actions">
      <button class="cancel" onclick="closeAddNodeModal()">Cancel</button>
      <button class="save-green" onclick="saveNewNode()">Add Node</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// DATA: Layers & Connection Types
// ============================================================
const LAYERS = {
  global:      { label: 'Global Config',   color: '#fbbf24', fill: '#422006', border: '#854d0e' },
  hq:          { label: 'Headquarters',     color: '#3b82f6', fill: '#172554', border: '#1d4ed8' },
  framework:   { label: 'Framework Guard',  color: '#ef4444', fill: '#450a0a', border: '#b91c1c' },
  routing:     { label: 'Routing / Agents', color: '#8b5cf6', fill: '#2e1065', border: '#6d28d9' },
  memory:      { label: 'Memory System',    color: '#10b981', fill: '#022c22', border: '#047857' },
  knowledge:   { label: 'Knowledge Base',   color: '#06b6d4', fill: '#083344', border: '#0e7490' },
  tools:       { label: 'Tools & Scripts',  color: '#f97316', fill: '#431407', border: '#c2410c' },
  tasks:       { label: 'Task System',      color: '#ec4899', fill: '#500724', border: '#be185d' },
  docs:        { label: 'Documentation',    color: '#64748b', fill: '#1e293b', border: '#475569' },
};

const CONN_TYPES = {
  route:      { label: '@-route',      color: '#3b82f6', dash: '',     desc: 'CLAUDE.md routing reference' },
  skill:      { label: 'skill/agent',  color: '#8b5cf6', dash: '8,4', desc: 'Agent or skill invocation' },
  reads:      { label: 'reads from',   color: '#10b981', dash: '6,3', desc: 'Data read / context load' },
  contains:   { label: 'contains',     color: '#64748b', dash: '3,3', desc: 'Parent-child containment' },
  lifecycle:  { label: 'lifecycle',    color: '#ec4899', dash: '12,4',desc: 'Task lifecycle flow' },
};

// ============================================================
// DATA: Nodes (mutable array)
// ============================================================
const nodes = [
  { id: 'global-claude',   label: 'CLAUDE.md',         subtitle: '/skogai/config/claude/CLAUDE.md',   layer: 'global',    x: 500, y: 40,  w: 160, h: 50, desc: 'Absolute entrypoint. Every session loads this first. Routes to user identity, definitions, and headquarters.' },
  { id: 'user-md',         label: 'user.md',           subtitle: '~/docs/skogix/user.md',             layer: 'global',    x: 180, y: 40,  w: 140, h: 50, desc: 'Who skogix is. Communication style, code preferences, knowledge sharing philosophy.' },
  { id: 'definitions-md',  label: 'definitions.md',    subtitle: '~/docs/skogix/definitions.md',      layer: 'global',    x: 820, y: 40,  w: 150, h: 50, desc: 'Terminology context. Defines: task, todo, plan, goal, agent, branch-name, @-prefix, etc.' },
  { id: 'hq-claude',       label: 'CLAUDE.md',         subtitle: '~/claude/CLAUDE.md',                layer: 'hq',        x: 500, y: 150, w: 160, h: 50, desc: 'Claude\'s home and working directory. Routes task work to task-manager agent, framework questions to .skogai.' },
  { id: 'skogai-claude',   label: '.skogai/CLAUDE.md', subtitle: '~/claude/.skogai/CLAUDE.md',        layer: 'framework', x: 780, y: 150, w: 170, h: 50, desc: 'Guard rule: "when .skogai contents are unclear, ask the user directly." Prevents guessing.' },
  { id: 'task-manager',    label: 'task-manager',      subtitle: '.claude/agents/task-manager.md',     layer: 'routing',   x: 280, y: 270, w: 160, h: 50, desc: 'Owns all skogai-todo interactions. Main claude instance delegates task work here. Full lifecycle: plan, setup, execute, done.' },
  { id: 'todo-plan',       label: '/todo:plan',        subtitle: '.claude/commands/todo/plan.md',      layer: 'routing',   x: 80,  y: 380, w: 130, h: 44, desc: 'Big picture planning: review all tasks, set dependencies, priorities, ordering.' },
  { id: 'todo-setup',      label: '/todo:setup',       subtitle: '.claude/commands/todo/setup.md',     layer: 'routing',   x: 230, y: 380, w: 130, h: 44, desc: 'Prepare a task: activate, lock, create worktree, write handover with context & acceptance criteria.' },
  { id: 'todo-execute',    label: '/todo:execute',     subtitle: '.claude/commands/todo/execute.md',   layer: 'routing',   x: 380, y: 380, w: 140, h: 44, desc: 'Do the work: read handover, implement in worktree, commit as you go, verify acceptance criteria.' },
  { id: 'todo-done',       label: '/todo:done',        subtitle: '.claude/commands/todo/done.md',      layer: 'routing',   x: 540, y: 380, w: 130, h: 44, desc: 'Close out: review, PR, unlock, set state done, sync GitHub, remove worktree.' },
  { id: 'memory-skogai',   label: 'SKOGAI.md',        subtitle: '.skogai/memory/SKOGAI.md',           layer: 'memory',    x: 720, y: 270, w: 140, h: 50, desc: 'Memory system overview. Defines structure: context/, decisions.md, journal/.' },
  { id: 'context-current', label: 'current.md',        subtitle: '.skogai/memory/context/current.md',  layer: 'memory',    x: 620, y: 380, w: 140, h: 44, desc: 'What we\'re actively working on. Read at session start, updated at session end.' },
  { id: 'decisions-log',   label: 'decisions.md',      subtitle: '.skogai/memory/decisions.md',         layer: 'memory',    x: 780, y: 380, w: 140, h: 44, desc: 'Append-only quick decision log. During work, append quick notes here.' },
  { id: 'journal',         label: 'journal/',          subtitle: '.skogai/memory/journal/*.md',         layer: 'memory',    x: 940, y: 380, w: 130, h: 44, desc: 'Timestamped session logs. Full history from 2025-03 through 2026-02.' },
  { id: 'conventions',     label: 'conventions.md',    subtitle: '.skogai/knowledge/conventions.md',    layer: 'knowledge', x: 80,  y: 510, w: 150, h: 44, desc: 'File/folder naming rules. SKOGAI.md, CLAUDE.md, INBOX.list, README.md roles defined here.' },
  { id: 'rules',           label: 'rules.md',          subtitle: '.skogai/knowledge/rules.md',          layer: 'knowledge', x: 250, y: 510, w: 130, h: 44, desc: 'Atomic rules: @ is not filesystem, .list files are append-only, inbox messaging protocol.' },
  { id: 'at-linking',      label: 'at-linking.md',     subtitle: '.skogai/docs/at-linking.md',          layer: 'knowledge', x: 400, y: 510, w: 140, h: 44, desc: 'CRITICAL: How @ notation works. @ = permission + context. Works 6 levels deep. Subagents need @-links to read files.' },
  { id: 'arch-decisions',  label: 'decisions/',        subtitle: '.skogai/knowledge/decisions/',         layer: 'knowledge', x: 560, y: 510, w: 150, h: 44, desc: 'Architecture Decision Records. Key dates: 2026-01-20 (conventions), 2026-02-06 (env), 2026-02-18 (task-manager).' },
  { id: 'skogai-todo',     label: 'skogai-todo.md',    subtitle: '.skogai/tools/skogai-todo.md',        layer: 'tools',     x: 720, y: 510, w: 150, h: 44, desc: 'Complete CLI reference for task management. Used exclusively by task-manager agent.' },
  { id: 'argcfile',        label: 'Argcfile.sh',       subtitle: '.skogai/Argcfile.sh',                 layer: 'tools',     x: 890, y: 510, w: 140, h: 44, desc: 'argc-based task runner framework. Shared automation scripts.' },
  { id: 'context-scripts', label: 'context/*.sh',      subtitle: '.skogai/scripts/context/',             layer: 'tools',     x: 890, y: 270, w: 150, h: 50, desc: 'Context loading orchestrator: git, journal, memory, model, todo, workspace context loaders.' },
  { id: 'task-files',      label: 'tasks/',            subtitle: '.skogai/tasks/*.md',                   layer: 'tasks',     x: 80,  y: 620, w: 130, h: 44, desc: '20+ task files with YAML frontmatter. Managed by skogai-todo CLI.' },
  { id: 'state-locks',     label: 'state/locks/',      subtitle: '.skogai/state/locks/',                 layer: 'tasks',     x: 250, y: 620, w: 140, h: 44, desc: 'Multi-agent coordination. Lock files prevent concurrent task work.' },
  { id: 'workflows-prep',  label: 'preparation.md',    subtitle: '.skogai/workflows/tasks/preparation.md',layer: 'tasks',    x: 420, y: 620, w: 150, h: 44, desc: 'How to prepare tasks: plan -> setup -> active. Worktree creation, handover writing.' },
  { id: 'workflows-exec',  label: 'execution.md',      subtitle: '.skogai/workflows/tasks/execution.md', layer: 'tasks',     x: 590, y: 620, w: 140, h: 44, desc: 'How to execute tasks: read handover, do work in worktree, commit, verify.' },
  { id: 'inbox',           label: 'inbox.list',        subtitle: '.skogai/inbox/inbox.list',              layer: 'tasks',     x: 760, y: 620, w: 130, h: 44, desc: 'Append-only message inbox. Cross-project communication channel.' },
  { id: 'dotfiles',        label: 'dotfiles/',         subtitle: '.skogai/dotfiles/',                    layer: 'docs',      x: 920, y: 620, w: 130, h: 44, desc: 'Git hooks (pre-commit, pre-push), branch validation, worktree tracking. Safety infrastructure.' },
  { id: 'nelson',          label: 'nelson/',           subtitle: '.skogai/projects/nelson/CLAUDE.md',    layer: 'routing',   x: 940, y: 150, w: 130, h: 50, desc: 'Sub-project with its own CLAUDE.md router. Royal Navy themed agent coordination skill.' },
];

// ============================================================
// DATA: Connections (mutable array)
// ============================================================
const connections = [
  { from: 'global-claude',  to: 'user-md',         type: 'route',    label: '@-ref' },
  { from: 'global-claude',  to: 'definitions-md',  type: 'route',    label: '@-ref' },
  { from: 'global-claude',  to: 'hq-claude',       type: 'route',    label: '@-ref' },
  { from: 'hq-claude',      to: 'task-manager',    type: 'route',    label: 'delegates tasks' },
  { from: 'hq-claude',      to: 'skogai-claude',   type: 'route',    label: 'framework ref' },
  { from: 'skogai-claude',  to: 'nelson',          type: 'route',    label: 'sub-project' },
  { from: 'task-manager',   to: 'todo-plan',       type: 'skill',    label: 'skill' },
  { from: 'task-manager',   to: 'todo-setup',      type: 'skill',    label: 'skill' },
  { from: 'task-manager',   to: 'todo-execute',    type: 'skill',    label: 'skill' },
  { from: 'task-manager',   to: 'todo-done',       type: 'skill',    label: 'skill' },
  { from: 'todo-plan',      to: 'todo-setup',      type: 'lifecycle', label: '1->2' },
  { from: 'todo-setup',     to: 'todo-execute',    type: 'lifecycle', label: '2->3' },
  { from: 'todo-execute',   to: 'todo-done',       type: 'lifecycle', label: '3->4' },
  { from: 'todo-setup',     to: 'workflows-prep',  type: 'reads',    label: '@-reads' },
  { from: 'todo-execute',   to: 'workflows-exec',  type: 'reads',    label: '@-reads' },
  { from: 'task-manager',   to: 'skogai-todo',     type: 'reads',    label: 'CLI ref' },
  { from: 'memory-skogai',  to: 'context-current',  type: 'contains' },
  { from: 'memory-skogai',  to: 'decisions-log',    type: 'contains' },
  { from: 'memory-skogai',  to: 'journal',           type: 'contains' },
  { from: 'context-scripts', to: 'memory-skogai',   type: 'reads',    label: 'loads' },
  { from: 'context-scripts', to: 'context-current',  type: 'reads',   label: 'loads' },
  { from: 'todo-plan',      to: 'task-files',       type: 'reads',    label: 'reads tasks' },
  { from: 'todo-setup',     to: 'state-locks',      type: 'reads',    label: 'acquires lock' },
  { from: 'todo-done',      to: 'state-locks',      type: 'reads',    label: 'releases lock' },
  { from: 'skogai-todo',    to: 'task-files',       type: 'reads',    label: 'manages' },
  { from: 'at-linking',     to: 'rules',            type: 'reads',    label: 'defines' },
  { from: 'conventions',    to: 'rules',            type: 'reads',    label: 'extends' },
  { from: 'todo-done',      to: 'inbox',            type: 'reads',    label: 'notifies' },
];

// ============================================================
// STATE
// ============================================================
const state = {
  layers: {},
  connTypes: {},
  comments: [],
  zoom: 1,
  panX: 0,
  panY: 0,
  preset: 'full',
  mode: 'view',            // 'view' | 'connect' | 'add'
  connectFrom: null,       // node id of first click in connect mode
  connectType: 'route',    // selected connection type for new connections
  addClickPos: null,       // {x, y} where user clicked to add node
  userNodes: [],            // ids of user-added nodes
  userConnections: [],      // indices into connections[] for user-added
  dragNode: null,           // node being dragged
  dragOffsetX: 0,
  dragOffsetY: 0,
};

Object.keys(LAYERS).forEach(k => state.layers[k] = true);
Object.keys(CONN_TYPES).forEach(k => state.connTypes[k] = true);

// ============================================================
// PRESETS
// ============================================================
const PRESETS = {
  full:       { label: 'Full System',     layers: Object.keys(LAYERS), desc: 'Everything visible' },
  routing:    { label: 'Routing Flow',    layers: ['global','hq','framework','routing'], desc: 'How CLAUDE.md files route to each other' },
  tasks:      { label: 'Task Lifecycle',  layers: ['routing','tasks','tools'], desc: 'plan -> setup -> execute -> done' },
  memory:     { label: 'Memory System',   layers: ['memory','tools','knowledge'], desc: 'How state persists across sessions' },
  knowledge:  { label: 'Knowledge Base',  layers: ['knowledge','docs'], desc: 'Rules, conventions, docs' },
  discovery:  { label: 'Agent Discovery', layers: ['global','hq','framework','routing','knowledge'], desc: 'How an agent finds what it needs' },
};

// ============================================================
// MODE MANAGEMENT
// ============================================================
function setMode(mode) {
  state.mode = mode;
  state.connectFrom = null;

  // Update button styles
  document.querySelectorAll('.mode-btn').forEach(b => b.className = 'mode-btn');
  const btn = document.getElementById('mode-' + mode);
  btn.classList.add('active' + (mode === 'connect' ? '-connect' : mode === 'add' ? '-add' : ''));

  // Update canvas cursor
  const area = document.getElementById('canvas-area');
  area.className = 'canvas-area' + (mode !== 'view' ? ' mode-' + mode : '');

  // Update hint
  const hints = {
    view: 'Click nodes to comment. Drag nodes to reposition. Scroll to zoom, drag canvas to pan.',
    connect: 'Click a source node, then click a target node to create a connection.',
    add: 'Click anywhere on the canvas to place a new node.',
  };
  document.getElementById('mode-hint').textContent = hints[mode];

  // Show/hide connect type selector
  document.getElementById('connect-type-sel').style.display = mode === 'connect' ? 'block' : 'none';

  // Reset connect pill
  const pill = document.getElementById('connect-pill');
  pill.classList.remove('show');

  renderDiagram();
}

// ============================================================
// RENDER: Sidebar
// ============================================================
function renderPresets() {
  document.getElementById('presets').innerHTML = Object.entries(PRESETS).map(([k, v]) =>
    `<button class="preset-btn ${state.preset === k ? 'active' : ''}" onclick="applyPreset('${k}')" title="${v.desc}">${v.label}</button>`
  ).join('');
}

function renderLayerToggles() {
  document.getElementById('layer-toggles').innerHTML = Object.entries(LAYERS).map(([k, v]) =>
    `<label class="layer-toggle">
      <input type="checkbox" ${state.layers[k] ? 'checked' : ''} onchange="toggleLayer('${k}')">
      <span class="layer-dot" style="background:${v.color}"></span>
      ${v.label}
    </label>`
  ).join('');
}

function renderConnToggles() {
  document.getElementById('conn-toggles').innerHTML = Object.entries(CONN_TYPES).map(([k, v]) =>
    `<label class="conn-toggle">
      <input type="checkbox" ${state.connTypes[k] ? 'checked' : ''} onchange="toggleConn('${k}')">
      <span class="conn-line" style="background:${v.color}; ${v.dash ? `background: repeating-linear-gradient(90deg, ${v.color} 0px, ${v.color} 4px, transparent 4px, transparent 7px)` : ''}"></span>
      ${v.label}
    </label>`
  ).join('');
}

function renderConnectTypeSelector() {
  const el = document.getElementById('connect-type-sel');
  const radios = Object.entries(CONN_TYPES).map(([k, v]) =>
    `<label><input type="radio" name="conn-type" value="${k}" ${state.connectType === k ? 'checked' : ''} onchange="state.connectType='${k}'">
      <span class="conn-line" style="display:inline-block;width:14px;height:2px;background:${v.color};vertical-align:middle;margin-right:2px"></span>
      ${v.label}</label>`
  ).join('');
  el.innerHTML = `<div style="font-size:10px;color:#64748b;text-transform:uppercase;margin-bottom:4px">Connection type</div>` + radios;
}

function renderComments() {
  const el = document.getElementById('comments-list');
  document.getElementById('comment-count').textContent = `(${state.comments.length})`;
  if (!state.comments.length) {
    el.innerHTML = '<div style="font-size:11px;color:#475569;padding:4px 0">Click any node in View mode to add a comment</div>';
    return;
  }
  el.innerHTML = state.comments.map((c, i) =>
    `<div class="comment-item">
      <span class="delete-btn" onclick="deleteComment(${i})">&#10005;</span>
      <div class="target">${c.targetLabel}</div>
      <div class="text">${c.text}</div>
    </div>`
  ).join('');
}

function renderAdditions() {
  const el = document.getElementById('additions-list');
  const total = state.userNodes.length + state.userConnections.length;
  document.getElementById('additions-count').textContent = `(${total})`;
  if (!total) {
    el.innerHTML = '<div style="font-size:11px;color:#475569;padding:4px 0">Use Connect or Add Node mode to build routes</div>';
    return;
  }
  let html = '';
  // User nodes
  state.userNodes.forEach(id => {
    const n = nodes.find(n => n.id === id);
    if (!n) return;
    html += `<div class="user-item">
      <span class="delete-btn" onclick="deleteUserNode('${id}')">&#10005;</span>
      <div class="target">+ ${n.label}</div>
      <div class="text">${n.subtitle}</div>
    </div>`;
  });
  // User connections
  state.userConnections.forEach(idx => {
    const c = connections[idx];
    if (!c) return;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    if (!fromN || !toN) return;
    html += `<div class="user-item">
      <span class="delete-btn" onclick="deleteUserConnection(${idx})">&#10005;</span>
      <div class="target">${fromN.label} &rarr; ${toN.label}</div>
      <div class="text">${CONN_TYPES[c.type].label}${c.label ? ': ' + c.label : ''}</div>
    </div>`;
  });
  el.innerHTML = html;
}

// ============================================================
// RENDER: SVG Diagram
// ============================================================
function getConnPoints(fromN, toN) {
  let sx, sy, ex, ey;
  // Same row: side-to-side
  if (Math.abs(fromN.y - toN.y) < 20) {
    if (fromN.x < toN.x) {
      sx = fromN.x + fromN.w; sy = fromN.y + fromN.h/2;
      ex = toN.x; ey = toN.y + toN.h/2;
    } else {
      sx = fromN.x; sy = fromN.y + fromN.h/2;
      ex = toN.x + toN.w; ey = toN.y + toN.h/2;
    }
  } else {
    // Vertical: bottom to top
    const fromBelow = fromN.y > toN.y;
    sx = fromN.x + fromN.w/2;
    sy = fromBelow ? fromN.y : fromN.y + fromN.h;
    ex = toN.x + toN.w/2;
    ey = fromBelow ? toN.y + toN.h : toN.y;
  }
  return { sx, sy, ex, ey };
}

function renderDiagram() {
  const svg = document.getElementById('diagram');
  const area = document.getElementById('canvas-area');
  const W = area.clientWidth;
  const H = area.clientHeight;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  let html = '<defs>';
  Object.entries(CONN_TYPES).forEach(([k, v]) => {
    html += `<marker id="arrow-${k}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
      <polygon points="0 0, 8 3, 0 6" fill="${v.color}" opacity="0.8"/>
    </marker>`;
  });
  html += '</defs>';

  html += `<g transform="translate(${state.panX + W/2 * (1 - state.zoom)}, ${state.panY + H/2 * (1 - state.zoom)}) scale(${state.zoom})">`;

  const visibleNodeIds = new Set(nodes.filter(n => state.layers[n.layer]).map(n => n.id));

  // Connections
  connections.forEach((c, idx) => {
    if (!state.connTypes[c.type]) return;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    if (!fromN || !toN) return;
    if (!visibleNodeIds.has(fromN.id) || !visibleNodeIds.has(toN.id)) return;

    const ct = CONN_TYPES[c.type];
    const { sx, sy, ex, ey } = getConnPoints(fromN, toN);
    const midY = (sy + ey) / 2;
    const d = `M ${sx} ${sy} C ${sx} ${midY}, ${ex} ${midY}, ${ex} ${ey}`;
    const isUser = state.userConnections.includes(idx);

    html += `<path d="${d}" fill="none" stroke="${ct.color}" stroke-width="${isUser ? 2.5 : 1.5}" stroke-opacity="${isUser ? 0.9 : 0.5}"
      stroke-dasharray="${ct.dash}" marker-end="url(#arrow-${c.type})"/>`;

    // Label for user connections
    if (isUser && c.label) {
      const lx = (sx + ex) / 2;
      const ly = (sy + ey) / 2 - 6;
      html += `<text x="${lx}" y="${ly}" text-anchor="middle" fill="${ct.color}" font-size="9" font-family="system-ui" opacity="0.8">${c.label}</text>`;
    }
  });

  // Nodes
  nodes.forEach(n => {
    if (!state.layers[n.layer]) return;
    const layer = LAYERS[n.layer];
    const hasComment = state.comments.some(c => c.target === n.id);
    const isUser = state.userNodes.includes(n.id);
    const isConnectSource = state.connectFrom === n.id;

    let borderStroke, borderWidth;
    if (isConnectSource) {
      borderStroke = '#fff'; borderWidth = 2.5;
    } else if (isUser) {
      borderStroke = '#10b981'; borderWidth = 2;
    } else if (hasComment) {
      borderStroke = layer.color; borderWidth = 2.5;
    } else {
      borderStroke = layer.border; borderWidth = 1;
    }

    html += `<g class="node" data-id="${n.id}" style="cursor:${state.mode === 'view' ? 'pointer' : state.mode === 'connect' ? 'crosshair' : 'pointer'}"
      onmouseenter="showTooltip(event, '${n.id}')" onmouseleave="hideTooltip()">`;

    // Background
    html += `<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="6" ry="6"
      fill="${layer.fill}" stroke="${borderStroke}" stroke-width="${borderWidth}" ${isUser ? 'stroke-dasharray="4,2"' : ''} />`;

    // User-added badge
    if (isUser) {
      html += `<circle cx="${n.x + 10}" cy="${n.y + 8}" r="4" fill="#10b981" />
        <text x="${n.x + 10}" y="${n.y + 11}" text-anchor="middle" fill="#fff" font-size="7" font-weight="700">+</text>`;
    }

    // Comment indicator
    if (hasComment) {
      html += `<circle cx="${n.x + n.w - 8}" cy="${n.y + 8}" r="4" fill="${layer.color}" />`;
    }

    // Label
    html += `<text x="${n.x + n.w/2}" y="${n.y + (n.h < 48 ? n.h/2 + 1 : n.h/2 - 4)}" text-anchor="middle"
      fill="${layer.color}" font-size="12" font-weight="600" font-family="'SF Mono', 'Fira Code', monospace">${escHtml(n.label)}</text>`;

    // Subtitle
    if (n.h >= 48) {
      const short = n.subtitle.length > 24 ? '...' + n.subtitle.slice(-22) : n.subtitle;
      html += `<text x="${n.x + n.w/2}" y="${n.y + n.h/2 + 10}" text-anchor="middle"
        fill="#475569" font-size="9" font-family="'SF Mono', monospace">${escHtml(short)}</text>`;
    }

    html += '</g>';
  });

  html += '</g>';
  svg.innerHTML = html;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}

// ============================================================
// RENDER: Legend
// ============================================================
function renderLegend() {
  const el = document.getElementById('legend');
  let html = '<div class="legend-title">Connection Types</div>';
  Object.entries(CONN_TYPES).forEach(([k, v]) => {
    if (!state.connTypes[k]) return;
    html += `<div class="legend-item">
      <svg width="24" height="8"><line x1="0" y1="4" x2="24" y2="4" stroke="${v.color}" stroke-width="2" stroke-dasharray="${v.dash}"/></svg>
      ${v.label}
    </div>`;
  });
  if (state.userNodes.length || state.userConnections.length) {
    html += '<div class="legend-item" style="margin-top:4px;color:#10b981"><svg width="24" height="8"><rect x="2" y="0" width="20" height="8" rx="2" fill="none" stroke="#10b981" stroke-width="1.5" stroke-dasharray="4,2"/></svg> your additions</div>';
  }
  el.innerHTML = html;
}

// ============================================================
// INTERACTIONS: Presets & Toggles
// ============================================================
function applyPreset(key) {
  state.preset = key;
  Object.keys(LAYERS).forEach(k => state.layers[k] = PRESETS[key].layers.includes(k));
  updateAll();
}

function toggleLayer(key) {
  state.layers[key] = !state.layers[key];
  state.preset = '';
  Object.entries(PRESETS).forEach(([k, v]) => {
    if (Object.keys(LAYERS).every(l => state.layers[l] === v.layers.includes(l))) state.preset = k;
  });
  updateAll();
}

function toggleConn(key) {
  state.connTypes[key] = !state.connTypes[key];
  updateAll();
}

// ============================================================
// INTERACTIONS: Tooltip
// ============================================================
function showTooltip(event, nodeId) {
  const n = nodes.find(n => n.id === nodeId);
  if (!n) return;
  const tt = document.getElementById('tooltip');
  tt.querySelector('.tt-label').textContent = n.label + (state.userNodes.includes(n.id) ? ' (new)' : '');
  tt.querySelector('.tt-path').textContent = n.subtitle;
  tt.querySelector('.tt-desc').textContent = n.desc;
  tt.style.display = 'block';

  const rect = document.getElementById('canvas-area').getBoundingClientRect();
  tt.style.left = Math.min(event.clientX - rect.left + 12, rect.width - 310) + 'px';
  tt.style.top = Math.min(event.clientY - rect.top + 12, rect.height - 100) + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// ============================================================
// INTERACTIONS: Canvas click dispatcher
// ============================================================
function svgToCanvas(clientX, clientY) {
  const area = document.getElementById('canvas-area');
  const rect = area.getBoundingClientRect();
  const W = rect.width, H = rect.height;
  const ox = state.panX + W/2 * (1 - state.zoom);
  const oy = state.panY + H/2 * (1 - state.zoom);
  return {
    x: (clientX - rect.left - ox) / state.zoom,
    y: (clientY - rect.top - oy) / state.zoom,
  };
}

function hitTestNode(cx, cy) {
  // Reverse order so top-rendered nodes hit first
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    if (!state.layers[n.layer]) continue;
    if (cx >= n.x && cx <= n.x + n.w && cy >= n.y && cy <= n.y + n.h) return n;
  }
  return null;
}

// Canvas mousedown
let isPanning = false, panStartX = 0, panStartY = 0;

document.getElementById('canvas-area').addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const { x, y } = svgToCanvas(e.clientX, e.clientY);
  const hitNode = hitTestNode(x, y);

  if (state.mode === 'view') {
    if (hitNode) {
      // Start drag
      state.dragNode = hitNode;
      state.dragOffsetX = x - hitNode.x;
      state.dragOffsetY = y - hitNode.y;
      e.preventDefault();
      return;
    }
    // Pan
    isPanning = true;
    panStartX = e.clientX - state.panX;
    panStartY = e.clientY - state.panY;

  } else if (state.mode === 'connect') {
    if (hitNode) {
      if (!state.connectFrom) {
        // First click: select source
        state.connectFrom = hitNode.id;
        const pill = document.getElementById('connect-pill');
        pill.textContent = 'From: ' + hitNode.label + ' â†’ click target...';
        pill.classList.add('show');
        document.getElementById('info-bar').textContent = 'Now click the target node';
        document.getElementById('info-bar').classList.add('highlight');
        renderDiagram();
      } else if (hitNode.id !== state.connectFrom) {
        // Second click: create connection
        createUserConnection(state.connectFrom, hitNode.id);
        state.connectFrom = null;
        document.getElementById('connect-pill').classList.remove('show');
        document.getElementById('info-bar').textContent = 'Connection created! Click another source node.';
        setTimeout(() => {
          document.getElementById('info-bar').textContent = 'Click a source node, then click a target node to create a connection.';
          document.getElementById('info-bar').classList.remove('highlight');
        }, 2000);
      } else {
        // Clicked same node: deselect
        state.connectFrom = null;
        document.getElementById('connect-pill').classList.remove('show');
        document.getElementById('info-bar').textContent = 'Deselected. Click a source node.';
        document.getElementById('info-bar').classList.remove('highlight');
        renderDiagram();
      }
    } else {
      // Clicked empty: pan
      isPanning = true;
      panStartX = e.clientX - state.panX;
      panStartY = e.clientY - state.panY;
    }

  } else if (state.mode === 'add') {
    if (!hitNode) {
      // Open add node modal at this position
      state.addClickPos = { x: Math.round(x - 70), y: Math.round(y - 25) };
      openAddNodeModal();
    } else {
      // Pan
      isPanning = true;
      panStartX = e.clientX - state.panX;
      panStartY = e.clientY - state.panY;
    }
  }
});

document.addEventListener('mousemove', e => {
  if (state.dragNode) {
    const { x, y } = svgToCanvas(e.clientX, e.clientY);
    state.dragNode.x = Math.round(x - state.dragOffsetX);
    state.dragNode.y = Math.round(y - state.dragOffsetY);
    renderDiagram();
    return;
  }
  if (!isPanning) return;
  state.panX = e.clientX - panStartX;
  state.panY = e.clientY - panStartY;
  renderDiagram();
});

document.addEventListener('mouseup', e => {
  if (state.dragNode) {
    state.dragNode = null;
    return;
  }
  if (!isPanning) return;
  isPanning = false;
  // If barely moved, treat as click (for view mode comment)
});

// Click handler for view mode comments (use click not mousedown)
document.getElementById('canvas-area').addEventListener('click', e => {
  if (state.mode !== 'view') return;
  const { x, y } = svgToCanvas(e.clientX, e.clientY);
  const hitNode = hitTestNode(x, y);
  if (hitNode) {
    openCommentModal(hitNode.id);
  }
});

// Scroll zoom
document.getElementById('canvas-area').addEventListener('wheel', e => {
  e.preventDefault();
  state.zoom = e.deltaY < 0
    ? Math.min(state.zoom * 1.08, 3)
    : Math.max(state.zoom / 1.08, 0.3);
  renderDiagram();
}, { passive: false });

// ============================================================
// CONNECT: Create user connection
// ============================================================
function createUserConnection(fromId, toId) {
  const c = {
    from: fromId,
    to: toId,
    type: state.connectType,
    label: CONN_TYPES[state.connectType].label,
    userAdded: true,
  };
  connections.push(c);
  state.userConnections.push(connections.length - 1);
  updateAll();
}

// ============================================================
// ADD NODE: Modal
// ============================================================
function openAddNodeModal() {
  const sel = document.getElementById('new-node-layer');
  sel.innerHTML = Object.entries(LAYERS).map(([k, v]) =>
    `<option value="${k}">${v.label}</option>`
  ).join('');
  document.getElementById('new-node-label').value = '';
  document.getElementById('new-node-path').value = '';
  document.getElementById('new-node-desc').value = '';
  document.getElementById('add-node-modal').classList.add('show');
  setTimeout(() => document.getElementById('new-node-label').focus(), 50);
}

function closeAddNodeModal() {
  document.getElementById('add-node-modal').classList.remove('show');
  state.addClickPos = null;
}

function saveNewNode() {
  const label = document.getElementById('new-node-label').value.trim();
  const path = document.getElementById('new-node-path').value.trim();
  const layer = document.getElementById('new-node-layer').value;
  const desc = document.getElementById('new-node-desc').value.trim();
  if (!label) return;

  const pos = state.addClickPos || { x: 500, y: 400 };
  const id = 'user-' + Date.now();
  const textLen = label.length * 8 + 30;
  const w = Math.max(130, Math.min(200, textLen));

  nodes.push({
    id, label,
    subtitle: path || label,
    layer,
    x: pos.x, y: pos.y,
    w, h: path ? 50 : 44,
    desc: desc || 'User-added node',
    userAdded: true,
  });
  state.userNodes.push(id);

  // Ensure layer is visible
  if (!state.layers[layer]) {
    state.layers[layer] = true;
    state.preset = '';
  }

  closeAddNodeModal();
  updateAll();
}

// ============================================================
// DELETE: User items
// ============================================================
function deleteUserNode(id) {
  // Remove connections to/from this node
  const connIdxToRemove = [];
  connections.forEach((c, i) => {
    if (c.from === id || c.to === id) connIdxToRemove.push(i);
  });
  // Remove from highest index first
  connIdxToRemove.sort((a, b) => b - a).forEach(i => {
    connections.splice(i, 1);
    state.userConnections = state.userConnections
      .filter(idx => idx !== i)
      .map(idx => idx > i ? idx - 1 : idx);
  });

  // Remove node
  const ni = nodes.findIndex(n => n.id === id);
  if (ni >= 0) nodes.splice(ni, 1);
  state.userNodes = state.userNodes.filter(nid => nid !== id);

  // Remove comments on this node
  state.comments = state.comments.filter(c => c.target !== id);

  updateAll();
}

function deleteUserConnection(idx) {
  connections.splice(idx, 1);
  state.userConnections = state.userConnections
    .filter(i => i !== idx)
    .map(i => i > idx ? i - 1 : i);
  updateAll();
}

// ============================================================
// COMMENT MODAL
// ============================================================
function openCommentModal(nodeId) {
  const n = nodes.find(n => n.id === nodeId);
  if (!n) return;
  state.modalNode = n;
  document.getElementById('comment-modal-title').textContent = n.label;
  document.getElementById('comment-modal-path').textContent = n.subtitle;
  document.getElementById('comment-modal-text').value = '';
  document.getElementById('comment-modal').classList.add('show');
  setTimeout(() => document.getElementById('comment-modal-text').focus(), 50);
}

function closeCommentModal() {
  document.getElementById('comment-modal').classList.remove('show');
  state.modalNode = null;
}

function saveComment() {
  const text = document.getElementById('comment-modal-text').value.trim();
  if (!text || !state.modalNode) return;
  state.comments.push({
    id: Date.now(),
    target: state.modalNode.id,
    targetLabel: state.modalNode.label,
    targetFile: state.modalNode.subtitle,
    text,
  });
  closeCommentModal();
  updateAll();
}

function deleteComment(index) {
  state.comments.splice(index, 1);
  updateAll();
}

// ============================================================
// ZOOM
// ============================================================
function zoomIn()    { state.zoom = Math.min(state.zoom * 1.2, 3); renderDiagram(); }
function zoomOut()   { state.zoom = Math.max(state.zoom / 1.2, 0.3); renderDiagram(); }
function zoomReset() { state.zoom = 1; state.panX = 0; state.panY = 0; renderDiagram(); }

// Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closeCommentModal();
    closeAddNodeModal();
    if (state.connectFrom) {
      state.connectFrom = null;
      document.getElementById('connect-pill').classList.remove('show');
      document.getElementById('info-bar').classList.remove('highlight');
      renderDiagram();
    }
  }
});

// ============================================================
// PROMPT GENERATION
// ============================================================
function updatePrompt() {
  const el = document.getElementById('prompt-output');
  const parts = [];

  // View context
  const visibleLayers = Object.entries(state.layers).filter(([,v]) => v).map(([k]) => LAYERS[k].label);
  const hiddenLayers = Object.entries(state.layers).filter(([,v]) => !v).map(([k]) => LAYERS[k].label);

  if (state.preset && PRESETS[state.preset]) {
    parts.push(`I'm looking at the SkogAI routing architecture, specifically the "${PRESETS[state.preset].label}" view.`);
  } else if (hiddenLayers.length > 0 && hiddenLayers.length <= visibleLayers.length) {
    parts.push(`I'm looking at the SkogAI routing architecture with these layers visible: ${visibleLayers.join(', ')}.`);
  } else {
    parts.push('I\'m looking at the full SkogAI routing architecture.');
  }

  const visibleNodeCount = nodes.filter(n => state.layers[n.layer]).length;
  const visibleConnCount = connections.filter(c => {
    if (!state.connTypes[c.type]) return false;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    return fromN && toN && state.layers[fromN.layer] && state.layers[toN.layer];
  }).length;
  parts.push(`Currently showing ${visibleNodeCount} components and ${visibleConnCount} connections.`);

  // Preset-specific context
  if (state.preset === 'routing') {
    parts.push('\nThe routing flow is: global CLAUDE.md -> user.md + definitions.md + headquarters CLAUDE.md -> task-manager agent + .skogai framework guard. Each CLAUDE.md acts as a minimal router that points to the next layer.');
  } else if (state.preset === 'tasks') {
    parts.push('\nThe task lifecycle is: /todo:plan (review & prioritize) -> /todo:setup (lock, worktree, handover) -> /todo:execute (do the work) -> /todo:done (PR, unlock, cleanup). The task-manager agent owns all skogai-todo interactions.');
  } else if (state.preset === 'memory') {
    parts.push('\nThe memory system: SKOGAI.md is the overview. context/current.md tracks active work (read at start, updated at end). decisions.md is append-only quick notes. journal/ has timestamped session history. Context scripts load this at session start.');
  } else if (state.preset === 'discovery') {
    parts.push('\nAgent discovery pattern: load ~/claude/CLAUDE.md -> see "use task-manager" -> read .claude/agents/task-manager.md -> see skills -> read commands -> find @-linked workflows -> find tool references. No guessing, every step is explicitly linked.');
  }

  // User additions
  if (state.userNodes.length || state.userConnections.length) {
    parts.push('\n--- Proposed additions to the routing architecture ---');

    if (state.userNodes.length) {
      parts.push('\nNew components:');
      state.userNodes.forEach(id => {
        const n = nodes.find(n => n.id === id);
        if (!n) return;
        parts.push(`- **${n.label}** (${n.subtitle}) [${LAYERS[n.layer].label}]: ${n.desc}`);
      });
    }

    if (state.userConnections.length) {
      parts.push('\nNew connections:');
      state.userConnections.forEach(idx => {
        const c = connections[idx];
        if (!c) return;
        const fromN = nodes.find(n => n.id === c.from);
        const toN = nodes.find(n => n.id === c.to);
        if (!fromN || !toN) return;
        parts.push(`- ${fromN.label} -> ${toN.label} (${CONN_TYPES[c.type].label})`);
      });
    }

    parts.push('\nPlease implement these routing changes in the .skogai structure.');
  }

  // Comments
  if (state.comments.length) {
    parts.push('\nFeedback on specific components:');
    state.comments.forEach(c => {
      parts.push(`\n**${c.targetLabel}** (${c.targetFile}):\n${c.text}`);
    });
  }

  el.textContent = parts.join('\n');
}

// ============================================================
// COPY
// ============================================================
function copyPrompt() {
  navigator.clipboard.writeText(document.getElementById('prompt-output').textContent).then(() => {
    const btn = document.getElementById('copy-btn');
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
  });
}

// ============================================================
// UPDATE ALL
// ============================================================
function updateAll() {
  renderPresets();
  renderLayerToggles();
  renderConnToggles();
  renderConnectTypeSelector();
  renderComments();
  renderAdditions();
  renderDiagram();
  renderLegend();
  updatePrompt();
}

// Init
updateAll();
window.addEventListener('resize', () => renderDiagram());
</script>

</body>
</html>
