<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SkogAI Routing Playground</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, sans-serif; background: #0f1117; color: #e2e8f0; height: 100vh; overflow: hidden; }

  .layout { display: grid; grid-template-columns: 280px 1fr; grid-template-rows: 1fr auto; height: 100vh; }

  /* Sidebar */
  .sidebar { grid-row: 1 / 3; background: #1a1d27; border-right: 1px solid #2d3348; overflow-y: auto; padding: 16px; }
  .sidebar h1 { font-size: 14px; font-weight: 700; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 12px; }
  .sidebar h2 { font-size: 12px; font-weight: 600; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; margin: 16px 0 8px; }

  /* Mode toolbar */
  .mode-bar { display: flex; gap: 4px; margin-bottom: 12px; }
  .mode-btn { flex: 1; padding: 6px 4px; font-size: 10px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; text-align: center; }
  .mode-btn:hover { background: #2d3348; color: #e2e8f0; }
  .mode-btn.active { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .mode-btn.active-connect { background: #8b5cf6; border-color: #8b5cf6; color: #fff; }
  .mode-btn.active-add { background: #10b981; border-color: #10b981; color: #fff; }

  .mode-hint { font-size: 10px; color: #475569; padding: 4px 0 8px; line-height: 1.4; border-bottom: 1px solid #2d3348; margin-bottom: 4px; }

  /* Connect type selector */
  .connect-type-sel { margin: 8px 0; padding: 8px; background: #252836; border: 1px solid #2d3348; border-radius: 4px; }
  .connect-type-sel label { display: flex; align-items: center; gap: 6px; font-size: 11px; padding: 2px 0; cursor: pointer; }
  .connect-type-sel input { accent-color: #8b5cf6; }

  /* Presets */
  .presets { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }
  .preset-btn { padding: 5px 10px; font-size: 11px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; }
  .preset-btn:hover { background: #2d3348; color: #e2e8f0; }
  .preset-btn.active { background: #3b82f6; border-color: #3b82f6; color: #fff; }

  /* Layer toggles */
  .layer-toggle { display: flex; align-items: center; gap: 8px; padding: 4px 0; cursor: pointer; font-size: 12px; }
  .layer-toggle input { accent-color: #3b82f6; }
  .layer-dot { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }

  /* Connection type toggles */
  .conn-toggle { display: flex; align-items: center; gap: 8px; padding: 3px 0; cursor: pointer; font-size: 12px; }
  .conn-line { width: 20px; height: 2px; display: inline-block; }

  /* Comments & user items */
  .comments-list { margin-top: 8px; }
  .comment-item, .user-item { background: #252836; border: 1px solid #2d3348; border-radius: 4px; padding: 8px; margin-bottom: 6px; font-size: 11px; }
  .comment-item .target, .user-item .target { color: #60a5fa; font-weight: 600; }
  .comment-item .text, .user-item .text { color: #94a3b8; margin-top: 4px; }
  .comment-item .delete-btn, .user-item .delete-btn { color: #ef4444; cursor: pointer; float: right; font-size: 10px; }
  .user-item { border-color: #10b981; }
  .user-item .target { color: #10b981; }
  .comment-count { color: #64748b; font-size: 11px; }

  /* Canvas area */
  .canvas-area { position: relative; overflow: hidden; background: #13151f; }
  .canvas-area svg { width: 100%; height: 100%; }
  .canvas-area.mode-connect { cursor: crosshair; }
  .canvas-area.mode-add { cursor: cell; }

  /* Zoom controls */
  .zoom-controls { position: absolute; top: 12px; right: 12px; display: flex; gap: 4px; }
  .zoom-btn { width: 28px; height: 28px; border: 1px solid #2d3348; background: #1a1d27; color: #94a3b8; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
  .zoom-btn:hover { background: #2d3348; color: #e2e8f0; }

  /* Legend */
  .legend { position: absolute; bottom: 12px; left: 12px; background: #1a1d27ee; border: 1px solid #2d3348; border-radius: 6px; padding: 10px 14px; font-size: 11px; }
  .legend-title { font-weight: 600; color: #64748b; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.05em; font-size: 10px; }
  .legend-item { display: flex; align-items: center; gap: 8px; padding: 2px 0; color: #94a3b8; }

  /* Prompt area */
  .prompt-area { background: #1a1d27; border-top: 1px solid #2d3348; padding: 12px 16px; max-height: 200px; overflow-y: auto; }
  .prompt-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .prompt-header span { font-size: 11px; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
  .copy-btn { padding: 4px 12px; font-size: 11px; border: 1px solid #2d3348; background: #252836; color: #94a3b8; border-radius: 4px; cursor: pointer; transition: all 0.15s; }
  .copy-btn:hover { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .copy-btn.copied { background: #10b981; border-color: #10b981; color: #fff; }
  .prompt-text { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px; line-height: 1.5; color: #cbd5e1; white-space: pre-wrap; }

  /* Tooltip */
  .tooltip { position: absolute; background: #252836; border: 1px solid #3b82f6; border-radius: 6px; padding: 10px 14px; font-size: 11px; pointer-events: none; z-index: 100; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); display: none; }
  .tooltip .tt-label { font-weight: 700; color: #e2e8f0; margin-bottom: 2px; }
  .tooltip .tt-path { color: #60a5fa; font-family: monospace; font-size: 10px; margin-bottom: 4px; }
  .tooltip .tt-desc { color: #94a3b8; line-height: 1.4; }

  /* Modals */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 200; display: none; align-items: center; justify-content: center; }
  .modal-overlay.show { display: flex; }
  .modal { background: #1a1d27; border: 1px solid #2d3348; border-radius: 8px; padding: 20px; width: 400px; }
  .modal h3 { font-size: 14px; margin-bottom: 4px; }
  .modal .modal-path { color: #60a5fa; font-family: monospace; font-size: 11px; margin-bottom: 12px; }
  .modal textarea, .modal input, .modal select { width: 100%; background: #252836; border: 1px solid #2d3348; border-radius: 4px; color: #e2e8f0; padding: 8px; font-size: 12px; font-family: system-ui; }
  .modal textarea { height: 60px; resize: vertical; }
  .modal input:focus, .modal textarea:focus, .modal select:focus { outline: none; border-color: #3b82f6; }
  .modal label.field { display: block; font-size: 11px; color: #64748b; margin: 10px 0 4px; text-transform: uppercase; letter-spacing: 0.03em; }
  .modal label.field:first-of-type { margin-top: 8px; }
  .modal-actions { display: flex; gap: 8px; margin-top: 14px; justify-content: flex-end; }
  .modal-actions button { padding: 6px 14px; border-radius: 4px; font-size: 12px; cursor: pointer; border: 1px solid #2d3348; }
  .modal-actions .cancel { background: #252836; color: #94a3b8; }
  .modal-actions .save { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .modal-actions .save-green { background: #10b981; border-color: #10b981; color: #fff; }

  /* Info bar */
  .info-bar { position: absolute; top: 12px; left: 12px; font-size: 11px; color: #475569; transition: color 0.2s; }
  .info-bar.highlight { color: #10b981; }

  /* Connection source highlight pill */
  .connect-source-pill { position: absolute; top: 44px; left: 12px; font-size: 11px; color: #8b5cf6; background: #2e1065; border: 1px solid #6d28d9; padding: 3px 10px; border-radius: 12px; display: none; }
  .connect-source-pill.show { display: inline-block; }
</style>
</head>
<body>

<div class="layout">
  <!-- Sidebar -->
  <div class="sidebar">
    <h1>SkogAI Routing</h1>

    <!-- Mode toolbar -->
    <div class="mode-bar">
      <button class="mode-btn active" id="mode-view" onclick="setMode('view')">View</button>
      <button class="mode-btn" id="mode-connect" onclick="setMode('connect')">Connect</button>
      <button class="mode-btn" id="mode-add" onclick="setMode('add')">Add Node</button>
    </div>
    <div class="mode-hint" id="mode-hint">Click nodes to comment. Scroll to zoom, drag to pan.</div>

    <!-- Connect type selector (visible in connect mode) -->
    <div class="connect-type-sel" id="connect-type-sel" style="display:none">
      <div style="font-size:10px;color:#64748b;text-transform:uppercase;margin-bottom:4px">Connection type</div>
    </div>

    <h2>View Presets</h2>
    <div class="presets" id="presets"></div>

    <h2>Layers</h2>
    <div id="layer-toggles"></div>

    <h2>Connection Types</h2>
    <div id="conn-toggles"></div>

    <h2>Your Additions <span class="comment-count" id="additions-count">(0)</span></h2>
    <div id="additions-list"></div>

    <h2>Comments <span class="comment-count" id="comment-count">(0)</span></h2>
    <div class="comments-list" id="comments-list"></div>

    <h2>Data</h2>
    <div style="display:flex;gap:6px">
      <button class="preset-btn" id="save-btn" onclick="saveToServer()" style="flex:1">Save</button>
      <button class="preset-btn" onclick="loadFromServer()" style="flex:1">Reload</button>
    </div>
    <div id="save-status" style="font-size:10px;color:#475569;margin-top:4px"></div>
  </div>

  <!-- Canvas -->
  <div class="canvas-area" id="canvas-area">
    <svg id="diagram" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()">+</button>
      <button class="zoom-btn" onclick="zoomOut()">&minus;</button>
      <button class="zoom-btn" onclick="zoomReset()" style="font-size:11px">1:1</button>
    </div>
    <div class="info-bar" id="info-bar">click nodes to comment &middot; scroll to zoom &middot; drag to pan</div>
    <div class="connect-source-pill" id="connect-pill"></div>
    <div class="legend" id="legend"></div>
    <div class="tooltip" id="tooltip">
      <div class="tt-label"></div>
      <div class="tt-path"></div>
      <div class="tt-desc"></div>
    </div>
  </div>

  <!-- Prompt output -->
  <div class="prompt-area">
    <div class="prompt-header">
      <span>Generated Prompt</span>
      <button class="copy-btn" id="copy-btn" onclick="copyPrompt()">Copy</button>
    </div>
    <div class="prompt-text" id="prompt-output"></div>
  </div>
</div>

<!-- Comment modal -->
<div class="modal-overlay" id="comment-modal">
  <div class="modal">
    <h3 id="comment-modal-title"></h3>
    <div class="modal-path" id="comment-modal-path"></div>
    <textarea id="comment-modal-text" placeholder="Add your comment about this component..."></textarea>
    <div class="modal-actions">
      <button class="cancel" onclick="closeCommentModal()">Cancel</button>
      <button class="save" onclick="saveComment()">Save Comment</button>
    </div>
  </div>
</div>

<!-- Add Node modal -->
<div class="modal-overlay" id="add-node-modal">
  <div class="modal">
    <h3>Add New Node</h3>
    <label class="field">Label (display name)</label>
    <input id="new-node-label" placeholder="e.g. my-agent.md" />
    <label class="field">Path</label>
    <input id="new-node-path" placeholder="e.g. .claude/agents/my-agent.md" />
    <label class="field">Layer</label>
    <select id="new-node-layer"></select>
    <label class="field">Description</label>
    <textarea id="new-node-desc" placeholder="What does this component do?"></textarea>
    <div class="modal-actions">
      <button class="cancel" onclick="closeAddNodeModal()">Cancel</button>
      <button class="save-green" onclick="saveNewNode()">Add Node</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// DATA: Loaded from API (or fallback defaults)
// ============================================================
let LAYERS = {};
let CONN_TYPES = {};

let nodes = [];
let connections = [];
let PRESETS = {};

// ============================================================
// STATE
// ============================================================
const state = {
  layers: {},
  connTypes: {},
  comments: [],
  zoom: 1,
  panX: 0,
  panY: 0,
  preset: 'full',
  mode: 'view',            // 'view' | 'connect' | 'add'
  connectFrom: null,       // node id of first click in connect mode
  connectType: 'route',    // selected connection type for new connections
  addClickPos: null,       // {x, y} where user clicked to add node
  userNodes: [],            // ids of user-added nodes
  userConnections: [],      // indices into connections[] for user-added
  removedConnections: [],   // indices of built-in connections marked for removal
  dragNode: null,           // node being dragged
  dragOffsetX: 0,
  dragOffsetY: 0,
};

Object.keys(LAYERS).forEach(k => state.layers[k] = true);
Object.keys(CONN_TYPES).forEach(k => state.connTypes[k] = true);

// ============================================================
// PRESETS
// ============================================================
// PRESETS loaded from API data

// ============================================================
// MODE MANAGEMENT
// ============================================================
function setMode(mode) {
  state.mode = mode;
  state.connectFrom = null;

  // Update button styles
  document.querySelectorAll('.mode-btn').forEach(b => b.className = 'mode-btn');
  const btn = document.getElementById('mode-' + mode);
  btn.classList.add('active' + (mode === 'connect' ? '-connect' : mode === 'add' ? '-add' : ''));

  // Update canvas cursor
  const area = document.getElementById('canvas-area');
  area.className = 'canvas-area' + (mode !== 'view' ? ' mode-' + mode : '');

  // Update hint
  const hints = {
    view: 'Click nodes to comment. Drag nodes to reposition. Scroll to zoom, drag canvas to pan.',
    connect: 'Click source, then target to toggle a connection. Same pair + type = remove.',
    add: 'Click anywhere on the canvas to place a new node.',
  };
  document.getElementById('mode-hint').textContent = hints[mode];

  // Show/hide connect type selector
  document.getElementById('connect-type-sel').style.display = mode === 'connect' ? 'block' : 'none';

  // Reset connect pill
  const pill = document.getElementById('connect-pill');
  pill.classList.remove('show');

  renderDiagram();
}

// ============================================================
// RENDER: Sidebar
// ============================================================
function renderPresets() {
  document.getElementById('presets').innerHTML = Object.entries(PRESETS).map(([k, v]) =>
    `<button class="preset-btn ${state.preset === k ? 'active' : ''}" onclick="applyPreset('${k}')" title="${v.desc}">${v.label}</button>`
  ).join('');
}

function renderLayerToggles() {
  document.getElementById('layer-toggles').innerHTML = Object.entries(LAYERS).map(([k, v]) =>
    `<label class="layer-toggle">
      <input type="checkbox" ${state.layers[k] ? 'checked' : ''} onchange="toggleLayer('${k}')">
      <span class="layer-dot" style="background:${v.color}"></span>
      ${v.label}
    </label>`
  ).join('');
}

function renderConnToggles() {
  document.getElementById('conn-toggles').innerHTML = Object.entries(CONN_TYPES).map(([k, v]) =>
    `<label class="conn-toggle">
      <input type="checkbox" ${state.connTypes[k] ? 'checked' : ''} onchange="toggleConn('${k}')">
      <span class="conn-line" style="background:${v.color}; ${v.dash ? `background: repeating-linear-gradient(90deg, ${v.color} 0px, ${v.color} 4px, transparent 4px, transparent 7px)` : ''}"></span>
      ${v.label}
    </label>`
  ).join('');
}

function renderConnectTypeSelector() {
  const el = document.getElementById('connect-type-sel');
  const radios = Object.entries(CONN_TYPES).map(([k, v]) =>
    `<label><input type="radio" name="conn-type" value="${k}" ${state.connectType === k ? 'checked' : ''} onchange="state.connectType='${k}'">
      <span class="conn-line" style="display:inline-block;width:14px;height:2px;background:${v.color};vertical-align:middle;margin-right:2px"></span>
      ${v.label}</label>`
  ).join('');
  el.innerHTML = `<div style="font-size:10px;color:#64748b;text-transform:uppercase;margin-bottom:4px">Connection type</div>` + radios;
}

function renderComments() {
  const el = document.getElementById('comments-list');
  document.getElementById('comment-count').textContent = `(${state.comments.length})`;
  if (!state.comments.length) {
    el.innerHTML = '<div style="font-size:11px;color:#475569;padding:4px 0">Click any node in View mode to add a comment</div>';
    return;
  }
  el.innerHTML = state.comments.map((c, i) =>
    `<div class="comment-item">
      <span class="delete-btn" onclick="deleteComment(${i})">&#10005;</span>
      <div class="target">${c.targetLabel}</div>
      <div class="text">${c.text}</div>
    </div>`
  ).join('');
}

function renderAdditions() {
  const el = document.getElementById('additions-list');
  const total = state.userNodes.length + state.userConnections.length + state.removedConnections.length;
  document.getElementById('additions-count').textContent = `(${total})`;
  if (!total) {
    el.innerHTML = '<div style="font-size:11px;color:#475569;padding:4px 0">Use Connect or Add Node mode to build routes</div>';
    return;
  }
  let html = '';
  // User nodes
  state.userNodes.forEach(id => {
    const n = nodes.find(n => n.id === id);
    if (!n) return;
    html += `<div class="user-item">
      <span class="delete-btn" onclick="deleteUserNode('${id}')">&#10005;</span>
      <div class="target">+ ${n.label}</div>
      <div class="text">${n.subtitle}</div>
    </div>`;
  });
  // User connections (added)
  state.userConnections.forEach(idx => {
    const c = connections[idx];
    if (!c) return;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    if (!fromN || !toN) return;
    html += `<div class="user-item">
      <span class="delete-btn" onclick="deleteUserConnection(${idx})">&#10005;</span>
      <div class="target">+ ${fromN.label} &rarr; ${toN.label}</div>
      <div class="text">${CONN_TYPES[c.type].label}${c.label ? ': ' + c.label : ''}</div>
    </div>`;
  });
  // Removed connections (proposed removals)
  state.removedConnections.forEach(idx => {
    const c = connections[idx];
    if (!c) return;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    if (!fromN || !toN) return;
    html += `<div class="user-item" style="border-color:#ef4444">
      <span class="delete-btn" onclick="restoreConnection(${idx})" title="Restore">&#8635;</span>
      <div class="target" style="color:#ef4444">&#10005; ${fromN.label} &rarr; ${toN.label}</div>
      <div class="text">${CONN_TYPES[c.type].label} (remove)</div>
    </div>`;
  });
  el.innerHTML = html;
}

// ============================================================
// RENDER: SVG Diagram
// ============================================================
function getConnPoints(fromN, toN) {
  let sx, sy, ex, ey;
  // Same row: side-to-side
  if (Math.abs(fromN.y - toN.y) < 20) {
    if (fromN.x < toN.x) {
      sx = fromN.x + fromN.w; sy = fromN.y + fromN.h/2;
      ex = toN.x; ey = toN.y + toN.h/2;
    } else {
      sx = fromN.x; sy = fromN.y + fromN.h/2;
      ex = toN.x + toN.w; ey = toN.y + toN.h/2;
    }
  } else {
    // Vertical: bottom to top
    const fromBelow = fromN.y > toN.y;
    sx = fromN.x + fromN.w/2;
    sy = fromBelow ? fromN.y : fromN.y + fromN.h;
    ex = toN.x + toN.w/2;
    ey = fromBelow ? toN.y + toN.h : toN.y;
  }
  return { sx, sy, ex, ey };
}

function renderDiagram() {
  const svg = document.getElementById('diagram');
  const area = document.getElementById('canvas-area');
  const W = area.clientWidth;
  const H = area.clientHeight;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  let html = '<defs>';
  Object.entries(CONN_TYPES).forEach(([k, v]) => {
    html += `<marker id="arrow-${k}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
      <polygon points="0 0, 8 3, 0 6" fill="${v.color}" opacity="0.8"/>
    </marker>`;
  });
  html += '</defs>';

  html += `<g transform="translate(${state.panX + W/2 * (1 - state.zoom)}, ${state.panY + H/2 * (1 - state.zoom)}) scale(${state.zoom})">`;

  const visibleNodeIds = new Set(nodes.filter(n => state.layers[n.layer]).map(n => n.id));

  // Connections
  connections.forEach((c, idx) => {
    if (!state.connTypes[c.type]) return;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    if (!fromN || !toN) return;
    if (!visibleNodeIds.has(fromN.id) || !visibleNodeIds.has(toN.id)) return;

    const ct = CONN_TYPES[c.type];
    const { sx, sy, ex, ey } = getConnPoints(fromN, toN);
    const midY = (sy + ey) / 2;
    const d = `M ${sx} ${sy} C ${sx} ${midY}, ${ex} ${midY}, ${ex} ${ey}`;
    const isUser = state.userConnections.includes(idx);
    const isRemoved = state.removedConnections.includes(idx);

    if (isRemoved) {
      // Removed: red, low opacity, with X marks along the path
      html += `<path d="${d}" fill="none" stroke="#ef4444" stroke-width="2" stroke-opacity="0.4"
        stroke-dasharray="4,4" marker-end="url(#arrow-${c.type})"/>`;
      // Strikethrough X at midpoint
      const mx = (sx + ex) / 2, my = (sy + ey) / 2;
      html += `<text x="${mx}" y="${my + 4}" text-anchor="middle" fill="#ef4444" font-size="12" font-weight="700" opacity="0.7">&#10005;</text>`;
    } else {
      html += `<path d="${d}" fill="none" stroke="${ct.color}" stroke-width="${isUser ? 2.5 : 1.5}" stroke-opacity="${isUser ? 0.9 : 0.5}"
        stroke-dasharray="${ct.dash}" marker-end="url(#arrow-${c.type})"/>`;
    }

    // Label for user connections
    if (isUser && c.label && !isRemoved) {
      const lx = (sx + ex) / 2;
      const ly = (sy + ey) / 2 - 6;
      html += `<text x="${lx}" y="${ly}" text-anchor="middle" fill="${ct.color}" font-size="9" font-family="system-ui" opacity="0.8">${c.label}</text>`;
    }
  });

  // Nodes
  nodes.forEach(n => {
    if (!state.layers[n.layer]) return;
    const layer = LAYERS[n.layer];
    const hasComment = state.comments.some(c => c.target === n.id);
    const isUser = state.userNodes.includes(n.id);
    const isConnectSource = state.connectFrom === n.id;

    let borderStroke, borderWidth;
    if (isConnectSource) {
      borderStroke = '#fff'; borderWidth = 2.5;
    } else if (isUser) {
      borderStroke = '#10b981'; borderWidth = 2;
    } else if (hasComment) {
      borderStroke = layer.color; borderWidth = 2.5;
    } else {
      borderStroke = layer.border; borderWidth = 1;
    }

    html += `<g class="node" data-id="${n.id}" style="cursor:${state.mode === 'view' ? 'pointer' : state.mode === 'connect' ? 'crosshair' : 'pointer'}"
      onmouseenter="showTooltip(event, '${n.id}')" onmouseleave="hideTooltip()">`;

    // Background — pill shape for endpoints, rounded rect for everything else
    const isEndpoint = layer.shape === 'pill';
    const rx = isEndpoint ? n.h / 2 : 6;
    const fillAttr = isEndpoint ? 'fill="#13151f"' : `fill="${layer.fill}"`;
    const dashAttr = isUser ? 'stroke-dasharray="4,2"' : isEndpoint ? 'stroke-dasharray="6,3"' : '';
    html += `<rect x="${n.x}" y="${n.y}" width="${n.w}" height="${n.h}" rx="${rx}" ry="${rx}"
      ${fillAttr} stroke="${borderStroke}" stroke-width="${borderWidth}" ${dashAttr} />`;

    // User-added badge
    if (isUser) {
      html += `<circle cx="${n.x + 10}" cy="${n.y + 8}" r="4" fill="#10b981" />
        <text x="${n.x + 10}" y="${n.y + 11}" text-anchor="middle" fill="#fff" font-size="7" font-weight="700">+</text>`;
    }

    // Comment indicator
    if (hasComment) {
      html += `<circle cx="${n.x + n.w - 8}" cy="${n.y + 8}" r="4" fill="${layer.color}" />`;
    }

    // Label
    html += `<text x="${n.x + n.w/2}" y="${n.y + (n.h < 48 ? n.h/2 + 1 : n.h/2 - 4)}" text-anchor="middle"
      fill="${layer.color}" font-size="12" font-weight="600" font-family="'SF Mono', 'Fira Code', monospace">${escHtml(n.label)}</text>`;

    // Subtitle
    if (n.h >= 48) {
      const short = n.subtitle.length > 24 ? '...' + n.subtitle.slice(-22) : n.subtitle;
      html += `<text x="${n.x + n.w/2}" y="${n.y + n.h/2 + 10}" text-anchor="middle"
        fill="#475569" font-size="9" font-family="'SF Mono', monospace">${escHtml(short)}</text>`;
    }

    html += '</g>';
  });

  html += '</g>';
  svg.innerHTML = html;
}

function escHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}

// ============================================================
// RENDER: Legend
// ============================================================
function renderLegend() {
  const el = document.getElementById('legend');
  let html = '<div class="legend-title">Connection Types</div>';
  Object.entries(CONN_TYPES).forEach(([k, v]) => {
    if (!state.connTypes[k]) return;
    html += `<div class="legend-item">
      <svg width="24" height="8"><line x1="0" y1="4" x2="24" y2="4" stroke="${v.color}" stroke-width="2" stroke-dasharray="${v.dash}"/></svg>
      ${v.label}
    </div>`;
  });
  if (state.layers.endpoint) {
    html += '<div class="legend-item" style="margin-top:4px;color:#e879f9"><svg width="24" height="8"><rect x="2" y="0" width="20" height="8" rx="4" fill="none" stroke="#a855f7" stroke-width="1.5" stroke-dasharray="6,3"/></svg> endpoint</div>';
  }
  if (state.userNodes.length || state.userConnections.length) {
    html += '<div class="legend-item" style="margin-top:4px;color:#10b981"><svg width="24" height="8"><rect x="2" y="0" width="20" height="8" rx="2" fill="none" stroke="#10b981" stroke-width="1.5" stroke-dasharray="4,2"/></svg> added</div>';
  }
  if (state.removedConnections.length) {
    html += '<div class="legend-item" style="color:#ef4444"><svg width="24" height="8"><line x1="0" y1="4" x2="24" y2="4" stroke="#ef4444" stroke-width="2" stroke-dasharray="4,4" opacity="0.5"/><text x="12" y="7" text-anchor="middle" fill="#ef4444" font-size="8" font-weight="700">&#10005;</text></svg> removed</div>';
  }
  el.innerHTML = html;
}

// ============================================================
// INTERACTIONS: Presets & Toggles
// ============================================================
function applyPreset(key) {
  state.preset = key;
  Object.keys(LAYERS).forEach(k => state.layers[k] = PRESETS[key].layers.includes(k));
  updateAll();
}

function toggleLayer(key) {
  state.layers[key] = !state.layers[key];
  state.preset = '';
  Object.entries(PRESETS).forEach(([k, v]) => {
    if (Object.keys(LAYERS).every(l => state.layers[l] === v.layers.includes(l))) state.preset = k;
  });
  updateAll();
}

function toggleConn(key) {
  state.connTypes[key] = !state.connTypes[key];
  updateAll();
}

// ============================================================
// INTERACTIONS: Tooltip
// ============================================================
function showTooltip(event, nodeId) {
  const n = nodes.find(n => n.id === nodeId);
  if (!n) return;
  const tt = document.getElementById('tooltip');
  tt.querySelector('.tt-label').textContent = n.label + (state.userNodes.includes(n.id) ? ' (new)' : '');
  tt.querySelector('.tt-path').textContent = n.subtitle;
  tt.querySelector('.tt-desc').textContent = n.desc;
  tt.style.display = 'block';

  const rect = document.getElementById('canvas-area').getBoundingClientRect();
  tt.style.left = Math.min(event.clientX - rect.left + 12, rect.width - 310) + 'px';
  tt.style.top = Math.min(event.clientY - rect.top + 12, rect.height - 100) + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// ============================================================
// INTERACTIONS: Canvas click dispatcher
// ============================================================
function svgToCanvas(clientX, clientY) {
  const area = document.getElementById('canvas-area');
  const rect = area.getBoundingClientRect();
  const W = rect.width, H = rect.height;
  const ox = state.panX + W/2 * (1 - state.zoom);
  const oy = state.panY + H/2 * (1 - state.zoom);
  return {
    x: (clientX - rect.left - ox) / state.zoom,
    y: (clientY - rect.top - oy) / state.zoom,
  };
}

function hitTestNode(cx, cy) {
  // Reverse order so top-rendered nodes hit first
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    if (!state.layers[n.layer]) continue;
    if (cx >= n.x && cx <= n.x + n.w && cy >= n.y && cy <= n.y + n.h) return n;
  }
  return null;
}

// Canvas mousedown
let isPanning = false, panStartX = 0, panStartY = 0;

document.getElementById('canvas-area').addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  const { x, y } = svgToCanvas(e.clientX, e.clientY);
  const hitNode = hitTestNode(x, y);

  if (state.mode === 'view') {
    if (hitNode) {
      // Start drag
      state.dragNode = hitNode;
      state.dragOffsetX = x - hitNode.x;
      state.dragOffsetY = y - hitNode.y;
      e.preventDefault();
      return;
    }
    // Pan
    isPanning = true;
    panStartX = e.clientX - state.panX;
    panStartY = e.clientY - state.panY;

  } else if (state.mode === 'connect') {
    if (hitNode) {
      if (!state.connectFrom) {
        // First click: select source
        state.connectFrom = hitNode.id;
        const pill = document.getElementById('connect-pill');
        pill.textContent = 'From: ' + hitNode.label + ' → click target...';
        pill.classList.add('show');
        document.getElementById('info-bar').textContent = 'Now click the target node';
        document.getElementById('info-bar').classList.add('highlight');
        renderDiagram();
      } else if (hitNode.id !== state.connectFrom) {
        // Second click: toggle connection
        const result = toggleConnection(state.connectFrom, hitNode.id);
        state.connectFrom = null;
        document.getElementById('connect-pill').classList.remove('show');
        document.getElementById('info-bar').textContent = result + ' Click another source node.';
        setTimeout(() => {
          document.getElementById('info-bar').textContent = 'Click source, then target to toggle a connection. Same pair + type = remove.';
          document.getElementById('info-bar').classList.remove('highlight');
        }, 2000);
      } else {
        // Clicked same node: deselect
        state.connectFrom = null;
        document.getElementById('connect-pill').classList.remove('show');
        document.getElementById('info-bar').textContent = 'Deselected. Click a source node.';
        document.getElementById('info-bar').classList.remove('highlight');
        renderDiagram();
      }
    } else {
      // Clicked empty: pan
      isPanning = true;
      panStartX = e.clientX - state.panX;
      panStartY = e.clientY - state.panY;
    }

  } else if (state.mode === 'add') {
    if (!hitNode) {
      // Open add node modal at this position
      state.addClickPos = { x: Math.round(x - 70), y: Math.round(y - 25) };
      openAddNodeModal();
    } else {
      // Pan
      isPanning = true;
      panStartX = e.clientX - state.panX;
      panStartY = e.clientY - state.panY;
    }
  }
});

document.addEventListener('mousemove', e => {
  if (state.dragNode) {
    const { x, y } = svgToCanvas(e.clientX, e.clientY);
    state.dragNode.x = Math.round(x - state.dragOffsetX);
    state.dragNode.y = Math.round(y - state.dragOffsetY);
    renderDiagram();
    return;
  }
  if (!isPanning) return;
  state.panX = e.clientX - panStartX;
  state.panY = e.clientY - panStartY;
  renderDiagram();
});

document.addEventListener('mouseup', e => {
  if (state.dragNode) {
    state.dragNode = null;
    return;
  }
  if (!isPanning) return;
  isPanning = false;
  // If barely moved, treat as click (for view mode comment)
});

// Click handler for view mode comments (use click not mousedown)
document.getElementById('canvas-area').addEventListener('click', e => {
  if (state.mode !== 'view') return;
  const { x, y } = svgToCanvas(e.clientX, e.clientY);
  const hitNode = hitTestNode(x, y);
  if (hitNode) {
    openCommentModal(hitNode.id);
  }
});

// Scroll zoom
document.getElementById('canvas-area').addEventListener('wheel', e => {
  e.preventDefault();
  state.zoom = e.deltaY < 0
    ? Math.min(state.zoom * 1.08, 3)
    : Math.max(state.zoom / 1.08, 0.3);
  renderDiagram();
}, { passive: false });

// ============================================================
// CONNECT: Toggle connection (create or remove)
// ============================================================
function toggleConnection(fromId, toId) {
  const type = state.connectType;

  // Check if this exact connection already exists
  const existingIdx = connections.findIndex(c =>
    c.from === fromId && c.to === toId && c.type === type
  );

  if (existingIdx >= 0) {
    const isUserAdded = state.userConnections.includes(existingIdx);
    const isRemoved = state.removedConnections.includes(existingIdx);

    if (isRemoved) {
      // Was marked for removal — restore it
      state.removedConnections = state.removedConnections.filter(i => i !== existingIdx);
      updateAll();
      return 'Connection restored!';
    } else if (isUserAdded) {
      // User-added — just delete it
      connections.splice(existingIdx, 1);
      state.userConnections = state.userConnections
        .filter(i => i !== existingIdx)
        .map(i => i > existingIdx ? i - 1 : i);
      state.removedConnections = state.removedConnections
        .map(i => i > existingIdx ? i - 1 : i);
      updateAll();
      return 'Connection removed!';
    } else {
      // Built-in — mark for removal (proposed change)
      state.removedConnections.push(existingIdx);
      updateAll();
      return 'Connection marked for removal!';
    }
  }

  // Also check reverse direction with same type
  const reverseIdx = connections.findIndex(c =>
    c.from === toId && c.to === fromId && c.type === type
  );
  if (reverseIdx >= 0) {
    const isUserAdded = state.userConnections.includes(reverseIdx);
    const isRemoved = state.removedConnections.includes(reverseIdx);

    if (isRemoved) {
      state.removedConnections = state.removedConnections.filter(i => i !== reverseIdx);
      updateAll();
      return 'Connection restored!';
    } else if (isUserAdded) {
      connections.splice(reverseIdx, 1);
      state.userConnections = state.userConnections
        .filter(i => i !== reverseIdx)
        .map(i => i > reverseIdx ? i - 1 : i);
      state.removedConnections = state.removedConnections
        .map(i => i > reverseIdx ? i - 1 : i);
      updateAll();
      return 'Connection removed!';
    } else {
      state.removedConnections.push(reverseIdx);
      updateAll();
      return 'Connection marked for removal!';
    }
  }

  // No existing connection — create new one
  const c = {
    from: fromId,
    to: toId,
    type: type,
    label: CONN_TYPES[type].label,
    userAdded: true,
  };
  connections.push(c);
  state.userConnections.push(connections.length - 1);
  updateAll();
  return 'Connection created!';
}

// ============================================================
// ADD NODE: Modal
// ============================================================
function openAddNodeModal() {
  const sel = document.getElementById('new-node-layer');
  sel.innerHTML = Object.entries(LAYERS).map(([k, v]) =>
    `<option value="${k}">${v.label}</option>`
  ).join('');
  document.getElementById('new-node-label').value = '';
  document.getElementById('new-node-path').value = '';
  document.getElementById('new-node-desc').value = '';
  document.getElementById('add-node-modal').classList.add('show');
  setTimeout(() => document.getElementById('new-node-label').focus(), 50);
}

function closeAddNodeModal() {
  document.getElementById('add-node-modal').classList.remove('show');
  state.addClickPos = null;
}

function saveNewNode() {
  const label = document.getElementById('new-node-label').value.trim();
  const path = document.getElementById('new-node-path').value.trim();
  const layer = document.getElementById('new-node-layer').value;
  const desc = document.getElementById('new-node-desc').value.trim();
  if (!label) return;

  const pos = state.addClickPos || { x: 500, y: 400 };
  const id = 'user-' + Date.now();
  const textLen = label.length * 8 + 30;
  const w = Math.max(130, Math.min(200, textLen));

  nodes.push({
    id, label,
    subtitle: path || label,
    layer,
    x: pos.x, y: pos.y,
    w, h: path ? 50 : 44,
    desc: desc || 'User-added node',
    userAdded: true,
  });
  state.userNodes.push(id);

  // Ensure layer is visible
  if (!state.layers[layer]) {
    state.layers[layer] = true;
    state.preset = '';
  }

  closeAddNodeModal();
  updateAll();
}

// ============================================================
// DELETE: User items
// ============================================================
function deleteUserNode(id) {
  // Remove connections to/from this node
  const connIdxToRemove = [];
  connections.forEach((c, i) => {
    if (c.from === id || c.to === id) connIdxToRemove.push(i);
  });
  // Remove from highest index first
  connIdxToRemove.sort((a, b) => b - a).forEach(i => {
    connections.splice(i, 1);
    state.userConnections = state.userConnections
      .filter(idx => idx !== i)
      .map(idx => idx > i ? idx - 1 : idx);
  });

  // Remove node
  const ni = nodes.findIndex(n => n.id === id);
  if (ni >= 0) nodes.splice(ni, 1);
  state.userNodes = state.userNodes.filter(nid => nid !== id);

  // Remove comments on this node
  state.comments = state.comments.filter(c => c.target !== id);

  updateAll();
}

function deleteUserConnection(idx) {
  connections.splice(idx, 1);
  state.userConnections = state.userConnections
    .filter(i => i !== idx)
    .map(i => i > idx ? i - 1 : i);
  state.removedConnections = state.removedConnections
    .map(i => i > idx ? i - 1 : i);
  updateAll();
}

function restoreConnection(idx) {
  state.removedConnections = state.removedConnections.filter(i => i !== idx);
  updateAll();
}

// ============================================================
// COMMENT MODAL
// ============================================================
function openCommentModal(nodeId) {
  const n = nodes.find(n => n.id === nodeId);
  if (!n) return;
  state.modalNode = n;
  document.getElementById('comment-modal-title').textContent = n.label;
  document.getElementById('comment-modal-path').textContent = n.subtitle;
  document.getElementById('comment-modal-text').value = '';
  document.getElementById('comment-modal').classList.add('show');
  setTimeout(() => document.getElementById('comment-modal-text').focus(), 50);
}

function closeCommentModal() {
  document.getElementById('comment-modal').classList.remove('show');
  state.modalNode = null;
}

function saveComment() {
  const text = document.getElementById('comment-modal-text').value.trim();
  if (!text || !state.modalNode) return;
  state.comments.push({
    id: Date.now(),
    target: state.modalNode.id,
    targetLabel: state.modalNode.label,
    targetFile: state.modalNode.subtitle,
    text,
  });
  closeCommentModal();
  updateAll();
}

function deleteComment(index) {
  state.comments.splice(index, 1);
  updateAll();
}

// ============================================================
// ZOOM
// ============================================================
function zoomIn()    { state.zoom = Math.min(state.zoom * 1.2, 3); renderDiagram(); }
function zoomOut()   { state.zoom = Math.max(state.zoom / 1.2, 0.3); renderDiagram(); }
function zoomReset() { state.zoom = 1; state.panX = 0; state.panY = 0; renderDiagram(); }

// Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closeCommentModal();
    closeAddNodeModal();
    if (state.connectFrom) {
      state.connectFrom = null;
      document.getElementById('connect-pill').classList.remove('show');
      document.getElementById('info-bar').classList.remove('highlight');
      renderDiagram();
    }
  }
});

// ============================================================
// PROMPT GENERATION
// ============================================================
function updatePrompt() {
  const el = document.getElementById('prompt-output');
  const parts = [];

  // View context
  const visibleLayers = Object.entries(state.layers).filter(([,v]) => v).map(([k]) => LAYERS[k].label);
  const hiddenLayers = Object.entries(state.layers).filter(([,v]) => !v).map(([k]) => LAYERS[k].label);

  if (state.preset && PRESETS[state.preset]) {
    parts.push(`I'm looking at the SkogAI routing architecture, specifically the "${PRESETS[state.preset].label}" view.`);
  } else if (hiddenLayers.length > 0 && hiddenLayers.length <= visibleLayers.length) {
    parts.push(`I'm looking at the SkogAI routing architecture with these layers visible: ${visibleLayers.join(', ')}.`);
  } else {
    parts.push('I\'m looking at the full SkogAI routing architecture.');
  }

  const visibleNodeCount = nodes.filter(n => state.layers[n.layer]).length;
  const visibleConnCount = connections.filter(c => {
    if (!state.connTypes[c.type]) return false;
    const fromN = nodes.find(n => n.id === c.from);
    const toN = nodes.find(n => n.id === c.to);
    return fromN && toN && state.layers[fromN.layer] && state.layers[toN.layer];
  }).length;
  parts.push(`Currently showing ${visibleNodeCount} components and ${visibleConnCount} connections.`);

  // Preset-specific context
  if (state.preset === 'routing') {
    parts.push('\nThe routing flow is: global CLAUDE.md -> user.md + definitions.md + headquarters CLAUDE.md -> task-manager agent + .skogai framework guard. Each CLAUDE.md acts as a minimal router that points to the next layer.');
  } else if (state.preset === 'tasks') {
    parts.push('\nThe task lifecycle is: /todo:plan (review & prioritize) -> /todo:setup (lock, worktree, handover) -> /todo:execute (do the work) -> /todo:done (PR, unlock, cleanup). The task-manager agent owns all skogai-todo interactions.');
  } else if (state.preset === 'memory') {
    parts.push('\nThe memory system: SKOGAI.md is the overview. context/current.md tracks active work (read at start, updated at end). decisions.md is append-only quick notes. journal/ has timestamped session history. Context scripts load this at session start.');
  } else if (state.preset === 'discovery') {
    parts.push('\nAgent discovery pattern: load ~/claude/CLAUDE.md -> see "use task-manager" -> read .claude/agents/task-manager.md -> see skills -> read commands -> find @-linked workflows -> find tool references. No guessing, every step is explicitly linked.');
  } else if (state.preset === 'boundary') {
    parts.push('\nSystem boundary view: internal routing components and the external tools/services they execute. Endpoints (pill-shaped) are the outer edge — CLI tools (skogai-todo, gh, git, argc), the terminal, GitHub remote, ollama, and the filesystem. "executes" connections show which internal component runs which tool. "I/O" connections show data flow to external systems.');
  }

  // User changes (additions + removals)
  const hasChanges = state.userNodes.length || state.userConnections.length || state.removedConnections.length;
  if (hasChanges) {
    parts.push('\n--- Proposed changes to the routing architecture ---');

    if (state.userNodes.length) {
      parts.push('\nAdd components:');
      state.userNodes.forEach(id => {
        const n = nodes.find(n => n.id === id);
        if (!n) return;
        parts.push(`- **${n.label}** (${n.subtitle}) [${LAYERS[n.layer].label}]: ${n.desc}`);
      });
    }

    if (state.userConnections.length) {
      parts.push('\nAdd connections:');
      state.userConnections.forEach(idx => {
        const c = connections[idx];
        if (!c) return;
        const fromN = nodes.find(n => n.id === c.from);
        const toN = nodes.find(n => n.id === c.to);
        if (!fromN || !toN) return;
        parts.push(`- ${fromN.label} -> ${toN.label} (${CONN_TYPES[c.type].label})`);
      });
    }

    if (state.removedConnections.length) {
      parts.push('\nRemove connections:');
      state.removedConnections.forEach(idx => {
        const c = connections[idx];
        if (!c) return;
        const fromN = nodes.find(n => n.id === c.from);
        const toN = nodes.find(n => n.id === c.to);
        if (!fromN || !toN) return;
        parts.push(`- ${fromN.label} -> ${toN.label} (${CONN_TYPES[c.type].label})`);
      });
    }

    parts.push('\nPlease implement these routing changes in the .skogai structure.');
  }

  // Comments
  if (state.comments.length) {
    parts.push('\nFeedback on specific components:');
    state.comments.forEach(c => {
      parts.push(`\n**${c.targetLabel}** (${c.targetFile}):\n${c.text}`);
    });
  }

  el.textContent = parts.join('\n');
}

// ============================================================
// COPY
// ============================================================
function copyPrompt() {
  navigator.clipboard.writeText(document.getElementById('prompt-output').textContent).then(() => {
    const btn = document.getElementById('copy-btn');
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
  });
}

// ============================================================
// UPDATE ALL
// ============================================================
function updateAll() {
  renderPresets();
  renderLayerToggles();
  renderConnToggles();
  renderConnectTypeSelector();
  renderComments();
  renderAdditions();
  renderDiagram();
  renderLegend();
  updatePrompt();
}

// ============================================================
// API: Load / Save
// ============================================================
function loadData(data) {
  LAYERS = data.layers || {};
  CONN_TYPES = data.connTypes || {};
  nodes.length = 0;
  connections.length = 0;
  (data.nodes || []).forEach(n => nodes.push(n));
  (data.connections || []).forEach(c => connections.push(c));
  PRESETS = data.presets || {};

  // Reset user state
  state.userNodes = [];
  state.userConnections = [];
  state.removedConnections = [];
  state.comments = [];
  state.connectFrom = null;

  // Init layer/conn visibility
  Object.keys(LAYERS).forEach(k => state.layers[k] = true);
  Object.keys(CONN_TYPES).forEach(k => state.connTypes[k] = true);
  state.preset = 'full';

  updateAll();
}

function buildSavePayload() {
  // Merge user additions into the base data for saving
  return {
    layers: LAYERS,
    connTypes: CONN_TYPES,
    nodes: nodes.map(n => {
      const { userAdded, ...rest } = n;
      return rest;
    }),
    connections: connections
      .filter((_, i) => !state.removedConnections.includes(i))
      .map(c => {
        const { userAdded, ...rest } = c;
        return rest;
      }),
    presets: PRESETS,
  };
}

async function loadFromServer() {
  const status = document.getElementById('save-status');
  try {
    const res = await fetch('/api/data');
    if (!res.ok) throw new Error(`${res.status}`);
    const data = await res.json();
    loadData(data);
    status.textContent = 'Loaded from server';
    status.style.color = '#10b981';
  } catch (e) {
    status.textContent = 'Load failed: ' + e.message;
    status.style.color = '#ef4444';
  }
  setTimeout(() => { status.textContent = ''; }, 3000);
}

async function saveToServer() {
  const status = document.getElementById('save-status');
  const btn = document.getElementById('save-btn');
  try {
    const res = await fetch('/api/data', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(buildSavePayload()),
    });
    if (!res.ok) throw new Error(`${res.status}`);
    btn.textContent = 'Saved!';
    btn.style.background = '#10b981';
    btn.style.borderColor = '#10b981';
    btn.style.color = '#fff';
    status.textContent = 'Saved to skogai-routing-data.json';
    status.style.color = '#10b981';

    // After save, user additions become part of the base
    state.userNodes = [];
    state.userConnections = [];
    state.removedConnections = [];
    renderAdditions();
    renderLegend();
  } catch (e) {
    status.textContent = 'Save failed: ' + e.message;
    status.style.color = '#ef4444';
  }
  setTimeout(() => {
    btn.textContent = 'Save';
    btn.style.background = '';
    btn.style.borderColor = '';
    btn.style.color = '';
    status.textContent = '';
  }, 2000);
}

// Init: load from API, fall back to empty
loadFromServer();
window.addEventListener('resize', () => renderDiagram());
</script>

</body>
</html>
